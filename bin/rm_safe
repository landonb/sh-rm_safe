#!/bin/bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=sh
# Project: https://github.com/landonb/sh-rm_safe#ðŸ—‘
# License: MIT

RM_SAFE_TRASH_HOME="${RM_SAFE_TRASH_HOME:-${HOME}}"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

source_deps () {
  local thispth="$1"
  local prefix=""
  local depsnok=false

  _source_it () {
    local prfx="${1:-.}"
    local depd="${2:-.}"
    local file="${3:-.}"
    local path="${prfx}/${depd}/${file}"
    if command -v "${file}" > /dev/null; then
      # Use version found on PATH.
      . "${file}"
    elif [ -f "${path}" ]; then
      # Fallback on local deps/ copy.
      # NOTE: `dash` complains if missing './'.
      . "${path}"
    else
      local depstxt=''
      [ "${prfx}" != "." ] && depstxt="in â€˜${prfx}/${depd}â€™ or "
      >&2 echo "MISSING: â€˜${file}â€™ not found ${depstxt}on PATH."
      depsnok=true
    fi
  }

  # Allow user to symlink executables and not libraries.
  prefix="$(dirname -- "$(readlink -e -- "${thispth}")")"

  # https://github.com/landonb/sh-colors
  _source_it "${prefix}" "../deps/sh-colors/bin" "colors.sh"

  . "$(dirname -- "${BASH_SOURCE[0]}")/path_device"

  ${depsnok}
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

_trace () { :; }
# YOU: Uncomment if you want a few runtime details.
#  _trace () { >&2 echo "$@"; }

_sh_rm_safe_device_filepath_for_file () {
  local file="$1"
  local device_path=''
  local usage_report=''
  # NOTE: We could use awk to get the second line of output, e.g.,
  #   usage_report=$(/bin/df -T "$1")
  #   device_path=$(echo "$usage_report" | awk 'NR == 2 {for(i=7;i<=NF;++i) print $i}')
  # but it seems easier to me (lb) -- or at least more intuitive -- to use tail-tr-cut.
  usage_report="$(/bin/df -T -- "${file}" | tail -1)"
  if [ $? -eq 0 ]; then
    device_path="$(echo "${usage_report}" | tr -s ' ' | cut -d ' ' -f7)"
    _trace "usage_report=${usage_report}"
  else
    if [ ! -L "${file}" ]; then
      # df didn't find file, and file not a symlink.
      echo "WARNING: Using relative path because not a file: ${file}"
    # else, df didn't find symlink because it points at non existant file.
    fi
    device_path="$( \
      /bin/df -T -- "$(dirname -- "${file}")" \
      | awk 'NR == 2 {for(i=7;i<=NF;++i) print $i}' \
    )"
  fi
  _trace "device_path=${device_path}"
  echo "${device_path}"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

_sh_rm_safe_ensure_trashdir () {
  local device_trashdir="$1"
  local trash_device="$2"
  local ensured=1
  if [ -z "${device_trashdir}" ]; then
    >&2 echo 'rm_safe: there is no $device_trashdir specified'
    ensured=1  # So caller does nothing more.
    return ${ensured}
  fi
  if [ -f "${device_trashdir}/.trash" ]; then
    ensured=2  # So caller invokes `rm -i`.
    # MAYBE: Suppress this message, or at least don't show multiple times for
    #        same ${trash_device}, i.e., on `rm *.*` would echo for every file.
    >&2 echo "The trash is disabled on device â€˜${trash_device}â€™"
  else
    if [ ! -e "${device_trashdir}/.trash" ]; then
      >&2 echo -e "No root trash found for device â€˜$(fg_lavender)${trash_device}$(attr_reset)â€™"
      sudo_prefix=""
      if [ "${device_trashdir}" = "/" ]; then
        # The file being deleted lives on the root device but the default
        # trash directory is not on the same device. This could mean the
        # user has an encrypted home directory. Rather than moving files
        # to the encryted space, use an unencrypted trash location, but
        # make the user do it.
        >&2 echo
        >&2 echo "No root trash directory â€˜/.trashâ€™ found on root device â€˜/â€™"
        >&2 echo
        >&2 echo "- Possibly because your home is encrypted, good job!"
        >&2 echo
        sudo_prefix="sudo"
        device_trashdir=''
      fi
      if ${echo_boxy}; then
        echo    "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${device_trashdir//?/â”€}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo    "â”‚ Create new trash at â€˜${device_trashdir}/.trashâ€™ ?   â”‚"
        echo -n "â”‚ Create trash? [y/N]:              ${device_trashdir//?/ }â”‚"
        echo -n -e "\r"
        echo -n "â”‚ Create trash? [y/N]: "
      else
        >&2 echo -e "- HINT: To skip this ask: $(fg_lavender)touch ${device_trashdir}/.trash$(attr_reset)"
        echo -n -e "rm_safe: create a new trash at â€˜$(fg_lavender)${device_trashdir}/.trash$(attr_reset)â€™? [y/N] "
      fi
      read the_choice
      if [ "${the_choice}" != "y" ] && [ "${the_choice}" != "Y" ]; then
        ensured=3  # So caller asks to move to home-trash; or invokes `rm -i`.
        if ${echo_boxy}; then
          >&2 echo "â”‚ HINT: To disable this ask:        ${device_trashdir//?/ }â”‚"
          >&2 echo "â”‚          touch ${device_trashdir}/.trash            â”‚"
          >&2 echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${device_trashdir//?/â”€}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
        fi
      else
        # We'll set ensured=4 in the [[ -d ]], last.
        ${sudo_prefix} /bin/mkdir -p "${device_trashdir}/.trash"
        if [ -n "${sudo_prefix}" ]; then
          sudo chgrp staff /.trash
          sudo chmod 2775 /.trash
        fi
      fi
    fi
    if [ -d "${device_trashdir}/.trash" ]; then
      ensured=4
    fi
  fi
  return ${ensured}
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# FIXME/2019-12-22 23:06: Split this long fcn.
# FIXME/2019-12-22 23:15: Honor `--` signalling end of options, to ignore -rf feature
#                         (i.e., treat "-rf" as filename).
rm_safe () {
  local rm_recursive_force=false
  if [ "-rf" = "${1}" ]; then
    >&2 echo "rm_safe: â€˜/bin/rm -rfâ€™, you got it!"
    shift
    rm_recursive_force=true
  fi
  if [ ${#*} -eq 0 ]; then
    >&2 echo "rm_safe: Missing operand(s)"
    >&2 echo "Try \`/bin/rm --help\` for more information"
    return 1
  fi
  if ${rm_recursive_force}; then
    /bin/rm -rf "$@"
    return 0
  fi
  if [ -z "${RM_SAFE_TRASH_HOME}" ]; then
    # We set RM_SAFE_TRASH_HOME in this file, so if here, DEV's fault.
    >&2 echo 'rm_safe: No $RM_SAFE_TRASH_HOME (â€˜â€™), what gives?'
    return 1
  fi
  # echo "RM_SAFE_TRASH_HOME: ${RM_SAFE_TRASH_HOME}"
  # The trash can way!
  # You can disable the trash by running
  #   /bin/rm -rf ~/.trash && touch ~/.trash
  # You can make the trash with rmtrash or mkdir ~/.trash,
  #   or run the command and you'll be prompted.
  # EXPLAIN/2019-12-22: (lb): Would $@ instead of $* allow us to avoid IFS?
  local old_IFS=$IFS
  IFS=$'\n'
  local fpath=""
  for fpath in $*; do
    local bname=$(basename -- "${fpath}")
    if [ "${bname}" = '.' ] || [ "${bname}" = '..' ]; then
      continue
    fi

    # A little trick to make sure to use the trash can on
    # the right device, to avoid copying files.
    # NOTE/2017-06-03: The device_on_which fcn. returns nonzero on error,
    # for reason the $? -ne 0 isn't seeing it (and I could swear that it
    # used to work!). So check for the empty string, too!
    local trash_device=$(path_device "${RM_SAFE_TRASH_HOME}")
    if [ $? -ne 0 ] || [ "${trash_device}" = "" ]; then
      >&2 echo "rm_safe: No device for supposed trash dir. â€˜${RM_SAFE_TRASH_HOME}â€™"
      return 1
    fi
    _trace "trash_device=${trash_device}"  # E.g., "/dev/sda2"

    local fpath_device
    fpath_device="$(path_device "${fpath}")"
    if [ $? -ne 0 ] || [ "${fpath_device}" == "" ]; then
      if [ ! -d "${fpath}" ] && [ ! -f "${fpath}" ] && [ ! -h "${fpath}" ]; then
        >&2 echo "rm_safe: Cannot remove â€˜${fpath}â€™: No such file or directory"
      else
        >&2 echo "rm_safe: ERROR: Could not detect device for item â€˜${fpath}â€™"
      fi
      return 1
    fi
    _trace "fpath_device=${fpath_device}"  # E.g., "/dev/sdb1"

    local device_trashdir=""
    if [ "${trash_device}" = "${fpath_device}" ]; then
      # MAYBE: Update this fcn. to support specific trash
      # directories on each device. For now you can specify
      # one specific dir for one drive (generally /home/$LOGNAME/.trash)
      # and then all other drives it's assumed to be at, e.g.,
      # /media/XXX/.trash.
      device_trashdir="${RM_SAFE_TRASH_HOME}"
    else
      device_trashdir=$(_sh_rm_safe_device_filepath_for_file "${fpath}")
      trash_device=${fpath_device}
    fi

    _sh_rm_safe_ensure_trashdir "${device_trashdir}" "${trash_device}"
    ensured=$?
    if [ ${ensured} -eq 3 ]; then
      # Ask if user wants to move file to home-trash instead.
      device_trashdir="${RM_SAFE_TRASH_HOME}"
      if ${echo_boxy}; then
        echo    "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${device_trashdir//?/â”€}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
        echo    "â”‚ Move to main trash at â€˜${device_trashdir}/.trashâ€™ ? â”‚"
        echo -n "â”‚ Move item? [y/N]:                 ${device_trashdir//?/ }â”‚"
        echo -n -e "\r"
        echo -n "â”‚ Move item? [y/N]: "
      else
        echo -n -e "rm_safe: move item to trash at â€˜$(fg_lavender)${device_trashdir}/.trash$(attr_reset)â€™? [y/N] "
      fi
      read the_choice
      if ${echo_boxy}; then
        >&2 echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${device_trashdir//?/â”€}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
      fi
      if [ "${the_choice}" != "y" ] && [ "${the_choice}" != "Y" ]; then
        ensured=2
      else
        ensured=4
      fi
    fi

    if [ ${ensured} -eq 2 ]; then
      # User specifically not using safety trash on this device; or for this file.
      /bin/rm -i "${fpath}"
    elif [ ${ensured} -eq 4 ]; then
      # ensured=4 means the trash directory exists; move 'deleted' files there.
      local fname=${bname}
      if [ -e "${device_trashdir}/.trash/${fname}" ] || \
         [ -h "${device_trashdir}/.trash/${fname}" ]; \
      then
        fname="${bname}.$(date +%Y_%m_%d_%Hh%Mm%Ss_%N)"
      fi
      # If fpath is a symlink and includes a trailing slash, doing a raw mv:
      #  /bin/mv "${fpath}" "${device_trashdir}/.trash/${fname}"
      # causes the response:
      #  /bin/mv: cannot move â€˜symlink/â€™ to
      #   â€˜/path/to/.trash/symlink.2015_12_03_14h26m51s_179228194â€™: Not a directory
      /bin/mv "$(dirname -- "${fpath}")/${bname}" "${device_trashdir}/.trash/${fname}"
    fi
  done
  IFS=$old_IFS
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

source_deps "${BASH_SOURCE[0]}"
unset -f source_deps

if [ "${BASH_SOURCE[0]}" = "$0" ]; then
  rm_safe "${@}"
else
  export -f rm_safe
fi

